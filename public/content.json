{"posts":[{"title":"开个新坑","text":"从两年前开始，一直在心心念念如何去完成这个网站，期间把 HTML、CSS、JS 之类的东西多多少少都学了一点，甚至用 SpringBoot 简单做了个后台服务器，到最后几乎都没用到就是了。有种有心栽花花不开，无心插柳柳成荫的美。不管怎么说，这也是一个好的开始，后续的打算是将以前写过的博客都搬运到这边来，同时也将好好完善一下这个网站。 话是这么说，要弄到什么时候就比较难讲了。首先之前的文章写得并不少，最重要的一个原因是，与其称之为博客，不如说是个知识点的归纳总结，从中能提炼出更多的博文······无妨，这东西没有 deadline，补到天荒地老又如何呢。","link":"/2023/06/22/at-first/"},{"title":"Linux Socket API 简明调用流程","text":"简单讲讲 Linux 的 Socket API 的调用通用流程，以及适用于已连接套接字的相关 API。 前置概念套接字是网络数据传输用的软件设备，表示两台计算机之间的连接（connection）。其中套接字可再细分为监听套接字和已连接套接字。 监听套接字则用于监听欲连接的主机，对于一个到达的新连接，对其生成一个已连接套接字。已连接套接字则为处于 ESTABLISHED 状态的套接字，用于与已连接客户通信。 套接字的初始化及其配置我们可以将从初始化套接字到建立套接字之间的连接的过程比作从安装电话到接通电话的过程。 socket() 函数可以用于初始化一个套接字，我将其看作安装电话这一步骤。其中该函数的用法如下。参数的含义留到后续的文章再作进一步的解释。 12// 返回**套接字**的**文件描述符（sockfd）**，失败则返回 -1。int socket(int domain, int type, int protocol); 初始化一个套接字之后，我们还需要对套接字绑定（bind）合适的地址和端口。我将这个过程比作给电话分配号码的过程。这里需要注意的是，不调用 bind() 不会影响后续的 connect() 或是 listen() 的调用，若没有调用 bind() 则内核会自动选择 IP 地址和合适的端口（对于监听套接字同样适用，但是一般不会这么做）。 12// 成功返回 0，失败则 -1。int bind(int sockfd, struct sockaddr *addr, socklen_t addrlen); 如果仅仅希望使用该套接字去连接（connect）到监听套接字，可以直接调用 connect() 函数而不需要调用 bind()，若成功调用，则该套接字就会转化为已连接套接字。 123// 成功返回 0，失败则返回 -1。/* pserv_addr 目标服务器的 addr。 */int connect(int csk, struct sockaddr *pserv_addr, socklen_t addrlen); 再讨论监听套接字的情况。绑定（bind）套接字之后，自然就是将套接字转换为监听套接字。这里我将其比作给电话接电话线的过程。 调用 listen()，将套接字转换为监听套接字，并指定排队（backlog）的最大连接个数。这里需要注意的是 backlog 参数并不完全等于实际的最大排队连接个数，backlog = 0 的行为是未定义的。 12// 成功返回 0，失败则 -1。int listen(int sockfd, int backlog); 经过一系列的操作，我们终于得到了监听套接字，此时已经可以接收到来自其他套接字的连接（connect），对于到达的连接，我们需要调用 accept() 来建立连接。这里我将其比作接听电话的过程。 12// 成功则返回一个新的文件描述符，对应一个新的已连接套接字，失败则返回 -1。int accept(int sockfd, struct sockaddr *paddr, socklen_t *addrlen); 建立连接后的操作简单提一下建立连接后的数据交换、获取对端或本端的地址信息需要用到的 API，以及其中的一些特性。 数据交换 数据交换通常会用到 read() 和 write() 函数。以下是阻塞情况下 read() 函数的返回值。 接收内容 返回值 数据或数据捎带的ACK 数据的字节数 FIN EOF 调用出错 -1 对于阻塞式 IO，未知需接收数据大小时，需自定义应用级 EOF 或利用 FIN 作为接收完毕的标志。 关闭连接 对已连接套接字调用 close() 以关闭该套接字对应的连接。调用后引用计数减 1，当引用计数为 0 时向对端发送 FIN。 获取对端/本端的套接字协议地址信息 可以通过调用 getsockname() 或 getpeername() 来获取某个套接字对应的 sockaddr。 123#include&lt;sys/socket.h&gt;int getsockname(int fd, struct sockaddr *localaddr, socklen_t *addrlen);int getpeername(int fd, struct sockaddr *peeraddr, socklen_t *addrlen); 调用 getsockname() 获取与该套接字相关联的本端协议地址。在未进行绑定（bind）的已连接套接字上获得内核赋予该连接（必须已经建立连接）的本地 IP 地址和本地端口。需在成功调用 connect() 或 accept() 后调用。调用 getpeername() 则可以获得对端的协议地址信息。","link":"/2023/03/06/socket-api-tutorial/"},{"title":"给 steamdeck 配置开发环境","text":"这东西简直就是个便携 linux 服务器！ 本文记录笔者在 steamdeck 上配置 gcc 编译环境时的经验。 发行版是 archlinux，魔改为 steamos，文章面向有 linux 使用基础但不熟悉 archlinux 的读者，不过大概也只有包管理器的差别。 1. 准备工作先设置密码，否则sudo不能用 1passwd 看一下 steamdeck 的分区结构，可以看到根目录的分区只有5GB空间，而且已经用掉了70%，仅剩下1.5GB的操作空间，这就要求我们只能用pacman安装最重要的软件包，不能一股脑地全部都用 pacman 安装。（这里不讨论改 pacman 安装目录的方法，可以预见地，引入的问题会比解决的问题要多得多。） 12345678910111213141516171819202122232425262728293031323334353637(1)(deck@steamdeck ~)$ lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTSzram0 254:0 0 7.2G 0 disk [SWAP]nvme0n1 259:0 0 476.9G 0 disk ├─nvme0n1p1 259:1 0 64M 0 part ├─nvme0n1p2 259:2 0 32M 0 part ├─nvme0n1p3 259:3 0 32M 0 part ├─nvme0n1p4 259:4 0 5G 0 part /├─nvme0n1p5 259:5 0 5G 0 part ├─nvme0n1p6 259:6 0 256M 0 part /var├─nvme0n1p7 259:7 0 256M 0 part └─nvme0n1p8 259:8 0 466.3G 0 part /var/tmp /var/log /var/lib/systemd/coredump /var/lib/steamos-log-submitter /var/lib/flatpak /var/lib/docker /var/cache/pacman /opt /nix /srv /root /home(deck@steamdeck ~)$ df -hFilesystem Size Used Avail Use% Mounted ondev 7.3G 0 7.3G 0% /devrun 7.3G 2.1M 7.3G 1% /runefivarfs 148K 11K 133K 8% /sys/firmware/efi/efivars/dev/nvme0n1p4 5.0G 3.5G 1.5G 70% //dev/nvme0n1p6 230M 34M 180M 16% /varoverlay 230M 34M 180M 16% /etctmpfs 7.3G 277M 7.0G 4% /dev/shmtmpfs 1.0M 0 1.0M 0% /run/credentials/systemd-journald.servicetmpfs 1.0M 0 1.0M 0% /run/credentials/systemd-resolved.service/dev/nvme0n1p8 458G 62G 396G 14% /hometmpfs 7.3G 7.3M 7.3G 1% /tmptmpfs 1.5G 4.1M 1.5G 1% /run/user/1000 关闭 steamos rootfs 写保护（rootfs 是根目录分区，pacman 安装的软件包都会放在 /usr ；总共只有5GB的空间！总共只有5GB的空间！） 1sudo steamos-readonly disable 导入 pacman 证书，否则什么也装不了 123sudo pacman-key --initsudo pacman-key --populate archlinuxsudo pacman-key --populate holo 或者直接使用 sudo steamos-devmode ，也能做完上述命令做的事情 12345678910111213141516(1)(deck@steamdeck ~)$ sudo steamos-devmode [sudo] password for deck: Usage: steamos-devmode enable|status [--no-prompt]A helper script to enable developer mode on SteamOS - Disables read-only mode. - Populates the pacman keyring.--no-prompt Skips interactive confirmationIf you wish to re-enable readonly mode after using this script, you can use the&quot;steamos-readonly enable&quot; command. This does not undo changes performedwhile in dev mode.See also `steamos-unminimize` 注意！这里不要使用 steamos-unminimize 配置环境，因为这个命令安装的软件包所需要的空间会比1.5GB要多，建议按照文章手动配置。 监听 ssh 连接 1sudo systemctl start sshd 2. 编译环境搭建update 一下 1sudo pacman -Syyy 实用工具（可选，等编译环境搭建好就可以自己编译一个） 1sudo pacman -S gnu-netcat 安装 gcc 1sudo pacman -S gcc 此时，gcc 还不能编译包含了 C/C++ 头文件的源文件，steamos 默认是没有带上这些头文件的，glibc 依赖也是坏的，这里需要手动安装一下 Basic tools to build Arch Linux packages 1sudo pacman -S base-devel 修复 glibc 并安装 C/C++ 头文件 1sudo pacmam -S glibc linux-api-headers 现在基本的依赖已经有了，写个 C++ 代码验证一下环境 3. 验证1234567891011121314151617181920212223242526/* test.cpp */#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;string_view&gt;#include &lt;functional&gt;// test for C++11using Caller = std::function&lt;void(std::string_view)&gt;;template &lt;typename ...Args&gt;void call(Args &amp;&amp;...args) { // test for C++14 static Caller f = [](auto s) { std::cout &lt;&lt; s &lt;&lt; '\\n'; }; f(std::forward&lt;std::string_view&gt;(args...));}int main() { // test for STL std::string s = &quot;hello steamos&quot;; // test for C++17 call(s); return 0;} 1234(deck@steamdeck ~)$ vim test.cpp (deck@steamdeck ~)$ g++ test.cpp (deck@steamdeck ~)$ ./a.out hello steamos 看起来 C++17 是能编译过的，基本的构建环境已经具备了。 看一下此时的 rootfs 还有多少空间，大约用掉了 200MB 12345678910111213Filesystem Size Used Avail Use% Mounted ondev 7.3G 0 7.3G 0% /devrun 7.3G 2.1M 7.3G 1% /runefivarfs 148K 11K 133K 8% /sys/firmware/efi/efivars/dev/nvme0n1p4 5.0G 3.6G 1.3G 74% //dev/nvme0n1p6 230M 34M 180M 16% /varoverlay 230M 34M 180M 16% /etctmpfs 7.3G 273M 7.0G 4% /dev/shmtmpfs 1.0M 0 1.0M 0% /run/credentials/systemd-journald.servicetmpfs 1.0M 0 1.0M 0% /run/credentials/systemd-resolved.service/dev/nvme0n1p8 458G 62G 396G 14% /hometmpfs 7.3G 7.3M 7.3G 1% /tmptmpfs 1.5G 4.1M 1.5G 1% /run/user/1000 3. 安装新的软件包？基本的构建能力已经具备，此时建议不要再使用 pacman 增加新的软件包，最好 sudo steamos-readonly enable，在用户分区增加自己的需要的软件，这里以 cmake 为例，介绍一下如何安装到自己指定的目录（~/.local）。 配置环境 创建 unix 风格的目录，这里仅列出部分常用的 123mkdir -p ~/.local/binmkdir -p ~/.local/sharemkdir -p ~/.local/man 修改 ~/.bashrc，添加环境变量 12# in ~/.bashrcexport PATH=$PATH:~/.local/bin 一般有两种方法配置 cmake 或其他工具：使用预构建的版本、手动编译 使用预构建的 cmake wget https://github.com/Kitware/CMake/releases/download/v3.31.6/cmake-3.31.6-linux-x86_64.tar.gz 解压，然后要么 mv cmake-3.31.6-linux-x86_64/* ~/.local，要么直接创建软链接 ln -s cmake-3.31.6-linux-x86_64/bin/* ~/.local/bin 手动编译 cmake wget https://github.com/Kitware/CMake/releases/download/v3.31.6/cmake-3.31.6.tar.gz 对于 autoconf 风格的工程，都可以如法炮制，便可以安装到指定的目录了 123./configure --prefix=~/.local -- -DCMAKE_USE_OPENSSL=OFFmake -j7make install 1234(deck@steamdeck cmake-3.31.6)$ cmake --versioncmake version 3.31.6CMake suite maintained and supported by Kitware (kitware.com/cmake). 卸载的话，只要在 install_manifest.txt 所在目录执行 make uninstall 即可。 4. 参考信息flatpak 换源 1flatpak remote-modify flathub --url=http://mirror.sjtu.edu.cn/flathub 后续可能会用到的环境变量 PATH MANPATH PKG_CONFIG_PATH LD_LIBRARY_PATH LD_RUN_PATH 介绍一下pacman包管理常用命令 12345678910# 获取更新信息sudo pacman -Sy# 安装软件包更新sudo pacman -Syyy# 更新系统内核sudo pacman -Syu# 安装软件包sudo pacman -S package_name# 卸载软件包sudo pacman -Rs package_name automake, autoconf使用详解 https://www.laruence.com/2009/11/18/1154.html","link":"/2026/02/01/steamdeck-env/"}],"tags":[{"name":"碎碎念","slug":"碎碎念","link":"/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"Socket","slug":"Socket","link":"/tags/Socket/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"},{"name":"Steamdeck","slug":"Steamdeck","link":"/tags/Steamdeck/"},{"name":"ArchLinux","slug":"ArchLinux","link":"/tags/ArchLinux/"}],"categories":[{"name":"垢","slug":"垢","link":"/categories/%E5%9E%A2/"},{"name":"Linux 网络编程","slug":"Linux-网络编程","link":"/categories/Linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Linux 运维","slug":"Linux-运维","link":"/categories/Linux-%E8%BF%90%E7%BB%B4/"},{"name":"垢","slug":"Linux-运维/垢","link":"/categories/Linux-%E8%BF%90%E7%BB%B4/%E5%9E%A2/"}],"pages":[]}